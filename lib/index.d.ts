/* This file was automatically generated by json-schema-to-typescript. */

/**
 * the entities that the subscription provides notifications for
 */
export type Include = string[]
/**
 * provider actions for this specific add-on
 */
export type Actions = {
  [k: string]: unknown
  /**
   * identifier of the action to take that is sent via SSO
   */
  action?: string
  /**
   * a unique identifier
   */
  id?: string
  /**
   * the display text shown in Dashboard
   */
  label?: string
  /**
   * if the action requires the user to own the app
   */
  requires_owner?: boolean
  /**
   * absolute URL to use instead of an action
   */
  url?: string
} & {
  [k: string]: unknown
}[]
/**
 * config vars exposed to the owning app by this add-on
 */
export type AddonConfigVars = string[]
/**
 * the compliance regimes applied to an add-on plan
 */
export type Compliance = ('HIPAA' | 'PCI')[] | null
/**
 * errors associated with invalid app.json manifest file
 */
export type ManifestErrors = string[]
/**
 * result of postdeploy script
 */
export type Postdeploy = {
  [k: string]: unknown
  /**
   * The exit code of the postdeploy script
   */
  exit_code?: number
  /**
   * output of the postdeploy script
   */
  output?: string
} & ({
  [k: string]: unknown
  /**
   * The exit code of the postdeploy script
   */
  exit_code?: number
  /**
   * output of the postdeploy script
   */
  output?: string
} | null)
/**
 * buildpacks executed for this build, in order
 */
export type Buildpacks =
  | {
      [k: string]: unknown
      /**
       * Buildpack Registry name of the buildpack for the app
       */
      name?: string
      /**
       * the URL of the buildpack for the app
       */
      url?: string
    }[]
  | null
  /**
 * release resulting from the build
 */
export type BuildRelease = {
  [k: string]: unknown
  /**
   * unique identifier of release
   */
  id?: string
} & ({
  [k: string]: unknown
  /**
   * unique identifier of release
   */
  id?: string
} | null)
/**
 * price information for this dyno size
 */
export type Cost = {
  [k: string]: unknown
} | null
/**
 * enterprise account permissions
 */
export type ExpandedPermissions = {
  [k: string]: unknown
  description?: string
  /**
   * permission in the enterprise account
   */
  name?: 'billing' | 'create' | 'manage' | 'view'
}[]
/**
 * Identity Provider information the member is federated with
 */
export type MemberIdentityProvider = {
  [k: string]: unknown
  /**
   * unique identifier of this identity provider
   */
  id?: string
  /**
   * name of the identity provider
   */
  name?: string
  owner?: Owner
  /**
   * whether the identity_provider information is redacted or not
   */
  redacted?: boolean
} & ({
  [k: string]: unknown
  /**
   * unique identifier of this identity provider
   */
  id?: string
  /**
   * name of the identity provider
   */
  name?: string
  owner?: Owner
  /**
   * whether the identity_provider information is redacted or not
   */
  redacted?: boolean
} | null)
/**
 * the current user's permissions for this enterprise account
 */
export type Permissions = string[]
/**
 * Identity Provider associated with the Enterprise Account
 */
export type IdentityProvider1 = {
  [k: string]: unknown
  /**
   * unique identifier of this identity provider
   */
  id?: string
  /**
   * user-friendly unique identifier for this identity provider
   */
  name?: string
  owner?: Owner
} & ({
  [k: string]: unknown
  /**
   * unique identifier of this identity provider
   */
  id?: string
  /**
   * user-friendly unique identifier for this identity provider
   */
  name?: string
  owner?: Owner
} | null)
/**
 * add-on that created the drain
 */
export type Addon = {
  [k: string]: unknown
  /**
   * billing application associated with this add-on
   */
  app?: {
    [k: string]: unknown
    /**
     * unique identifier of app
     */
    id?: string
    /**
     * unique name of app
     */
    name?: string
  }
  /**
   * unique identifier of add-on
   */
  id?: string
  /**
   * globally unique name of the add-on
   */
  name?: string
} & ({
  [k: string]: unknown
  /**
   * billing application associated with this add-on
   */
  app?: {
    [k: string]: unknown
    /**
     * unique identifier of app
     */
    id?: string
    /**
     * unique name of app
     */
    name?: string
  }
  /**
   * unique identifier of add-on
   */
  id?: string
  /**
   * globally unique name of the add-on
   */
  name?: string
} | null)
/**
 * application that is attached to this drain
 */
export type App1 = {
  [k: string]: unknown
  /**
   * unique identifier of app
   */
  id?: string
  /**
   * unique name of app
   */
  name?: string
} & ({
  [k: string]: unknown
  /**
   * unique identifier of app
   */
  id?: string
  /**
   * unique name of app
   */
  name?: string
} | null)
/**
 * The scope of access OAuth authorization allows
 */
export type Scope = string[]
/**
 * Owner of a pipeline.
 */
export type Owner2 = {
  [k: string]: unknown
  /**
   * unique identifier of a pipeline owner
   */
  id: string
  /**
   * type of pipeline owner
   */
  type: string
} & ({
  [k: string]: unknown
  /**
   * unique identifier of a pipeline owner
   */
  id: string
  /**
   * type of pipeline owner
   */
  type: string
} | null)
/**
 * the deploy target for the review apps of a pipeline
 */
export type DeployTarget = {
  [k: string]: unknown
  /**
   * unique identifier of deploy target
   */
  id: string
  /**
   * type of deploy target
   */
  type: string
} & ({
  [k: string]: unknown
  /**
   * unique identifier of deploy target
   */
  id: string
  /**
   * type of deploy target
   */
  type: string
} | null)
/**
 * domains associated with this SSL certificate
 */
export type Domains = string[]
export type CertDomains = unknown[]
/**
 * potential IPs from which outbound network traffic will originate
 */
export type Sources = string[]
export type EnterpriseAccount1 = {
  [k: string]: unknown
  /**
   * unique identifier of the enterprise account
   */
  id?: string
  /**
   * unique name of the enterprise account
   */
  name?: string
} & ({
  [k: string]: unknown
  /**
   * unique identifier of the enterprise account
   */
  id?: string
  /**
   * unique name of the enterprise account
   */
  name?: string
} | null)
/**
 * Identity Provider associated with the Team
 */
export type IdentityProvider2 = {
  [k: string]: unknown
  /**
   * unique identifier of this identity provider
   */
  id?: string
  /**
   * user-friendly unique identifier for this identity provider
   */
  name?: string
  owner?: Owner
} & ({
  [k: string]: unknown
  /**
   * unique identifier of this identity provider
   */
  id?: string
  /**
   * user-friendly unique identifier for this identity provider
   */
  name?: string
  owner?: Owner
} | null)

/**
 * Which pipeline uuids the user has dismissed the GitHub banner for
 */
export type DismissedPipelinesGithubBanners = null | string[]
/**
 * Routable CIDRs of VPN
 */
export type RoutableCidrs = string[]

/**
 * The platform API empowers developers to automate, extend and combine Heroku with other services.
 */
export interface HerokuPlatformAPI {
  [k: string]: unknown
  account?: Account
  'account-delinquency'?: AccountDelinquency
  'account-feature'?: AccountFeature
  'add-on'?: AddOn
  'add-on-action'?: AddOnAction
  'add-on-attachment'?: AddOnAttachment
  'add-on-config'?: AddOnConfig
  'add-on-plan-action'?: AddOnPlanAction
  'add-on-region-capability'?: AddOnRegionCapability
  'add-on-service'?: AddOnService
  'add-on-webhook'?: AddOnWebhook
  'add-on-webhook-delivery'?: AddOnWebhookDelivery
  'add-on-webhook-event'?: AddOnWebhookEvent
  'allowed-add-on-service'?: AllowedAddOnService
  app?: App
  'app-feature'?: AppFeature
  'app-setup'?: AppSetup
  'app-transfer'?: AppTransfer
  'app-webhook'?: AppWebhook
  'app-webhook-delivery'?: AppWebhookDelivery
  'app-webhook-event'?: AppWebhookEvent
  archive?: AuditTrailArchive
  'audit-trail-event'?: AuditTrailEvent
  build?: Build
  'buildpack-installation'?: BuildpackInstallations
  collaborator?: Collaborator
  'config-var'?: ConfigVars
  credit?: Credit
  domain?: Domain
  dyno?: Dyno
  'dyno-size'?: DynoSize
  'enterprise-account'?: EnterpriseAccount
  'enterprise-account-daily-usage'?: EnterpriseAccountDailyUsage
  'enterprise-account-member'?: EnterpriseAccountMember
  'enterprise-account-monthly-usage'?: EnterpriseAccountMonthlyUsage
  'filter-apps'?: Filters
  formation?: Formation
  'identity-provider'?: IdentityProvider
  'inbound-ruleset'?: InboundRuleset
  invoice?: Invoice
  'invoice-address'?: InvoiceAddress
  key?: Key
  'log-drain'?: LogDrain
  'log-session'?: LogSession
  'oauth-authorization'?: OAuthAuthorization
  'oauth-client'?: OAuthClient
  'oauth-grant'?: OAuthGrant
  'oauth-token'?: OAuthToken
  'password-reset'?: PasswordReset
  peering?: Peering
  'peering-info'?: PeeringInfo
  'permission-entity'?: PermissionEntity
  pipeline?: Pipeline
  'pipeline-build'?: PipelineBuild
  'pipeline-config-var'?: PipelineConfigVars
  'pipeline-coupling'?: PipelineCoupling
  'pipeline-deployment'?: PipelineDeployment
  'pipeline-promotion'?: PipelinePromotion
  'pipeline-promotion-target'?: PipelinePromotionTarget
  'pipeline-release'?: PipelineRelease
  'pipeline-stack'?: PipelineStack
  'pipeline-transfer'?: PipelineTransfer
  plan?: Plan
  'rate-limit'?: RateLimit
  region?: Region
  release?: Release
  'review-app'?: ReviewApp
  'review-app-config'?: ReviewAppConfiguration
  slug?: Slug
  'sms-number'?: SMSNumber
  'sni-endpoint'?: SNIEndpoint
  source?: Source
  space?: Space
  'space-app-access'?: SpaceAccess
  'space-nat'?: SpaceNetworkAddressTranslation
  'space-topology'?: SpaceTopology
  'space-transfer'?: SpaceTransfer
  stack?: Stack
  team?: Team
  'team-add-on'?: TeamAddOn
  'team-app'?: TeamApp
  'team-app-collaborator'?: TeamAppCollaborator
  'team-app-permission'?: TeamAppPermission
  'team-daily-usage'?: TeamDailyUsage
  'team-delinquency'?: TeamDelinquency
  'team-feature'?: TeamFeature
  'team-invitation'?: TeamInvitation
  'team-invoice'?: TeamInvoice
  'team-member'?: TeamMember
  'team-monthly-usage'?: TeamMonthlyUsage
  'team-preferences'?: TeamPreferences
  'team-space'?: TeamSpace
  'test-case'?: TestCase
  'test-node'?: TestNode
  'test-run'?: TestRun
  'user-preferences'?: UserPreferences
  'vpn-connection'?: PrivateSpacesVPN
}
/**
 * A Heroku account becomes delinquent due to non-payment. We [suspend and delete](https://help.heroku.com/EREVRILX/what-happens-if-i-have-unpaid-heroku-invoices) delinquent accounts if their invoices remain unpaid.
 */
export interface AccountDelinquency {
  [k: string]: unknown
  /**
   * scheduled time of when we will delete your account due to delinquency
   */
  scheduled_deletion_time?: null | string
  /**
   * scheduled time of when we will suspend your account due to delinquency
   */
  scheduled_suspension_time?: null | string
}
/**
 * An account feature represents a Heroku labs capability that can be enabled or disabled for an account on Heroku.
 */
export interface AccountFeature {
  [k: string]: unknown
  /**
   * when account feature was created
   */
  created_at?: string
  /**
   * description of account feature
   */
  description?: string
  /**
   * user readable feature name
   */
  display_name?: string
  /**
   * documentation URL of account feature
   */
  doc_url?: string
  /**
   * whether or not account feature has been enabled
   */
  enabled?: boolean
  /**
   * e-mail to send feedback about the feature
   */
  feedback_email?: string
  /**
   * unique identifier of account feature
   */
  id?: string
  /**
   * unique name of account feature
   */
  name?: string
  /**
   * state of account feature
   */
  state?: string
  /**
   * when account feature was updated
   */
  updated_at?: string
}
/**
 * An account represents an individual signed up to use the Heroku platform.
 */
export interface Account {
  [k: string]: unknown
  /**
   * whether to allow third party web activity tracking
   */
  allow_tracking?: boolean
  /**
   * whether allowed to utilize beta Heroku features
   */
  beta?: boolean
  /**
   * country where account owner resides
   */
  country_of_residence?: null | string
  /**
   * when account was created
   */
  created_at?: string
  /**
   * team selected by default
   */
  default_organization?: {
    [k: string]: unknown
    /**
     * unique identifier of team
     */
    id?: string
    /**
     * unique name of team
     */
    name?: string
  } | null
  /**
   * team selected by default
   */
  default_team?: {
    [k: string]: unknown
    /**
     * unique identifier of team
     */
    id?: string
    /**
     * unique name of team
     */
    name?: string
  } | null
  /**
   * when account became delinquent
   */
  delinquent_at?: null | string
  /**
   * unique email address of account
   */
  email?: string
  /**
   * whether the user is federated and belongs to an Identity Provider
   */
  federated?: boolean
  /**
   * unique identifier of an account
   */
  id?: string
  /**
   * Identity Provider details for federated users.
   */
  identity_provider?: {
    [k: string]: unknown
    /**
     * unique identifier of this identity provider
     */
    id?: string
    /**
     * user-friendly unique identifier for this identity provider
     */
    name?: string
    organization?: {
      [k: string]: unknown
      /**
       * unique name of team
       */
      name?: string
    }
    owner?: Owner
    team?: {
      [k: string]: unknown
      /**
       * unique name of team
       */
      name?: string
    }
  } | null
  /**
   * when account last authorized with Heroku
   */
  last_login?: null | string
  /**
   * full name of the account owner
   */
  name?: null | string
  /**
   * SMS number of account
   */
  sms_number?: null | string
  /**
   * when account was suspended
   */
  suspended_at?: null | string
  /**
   * whether two-factor auth is enabled on the account
   */
  two_factor_authentication?: boolean
  /**
   * when account was updated
   */
  updated_at?: string
  /**
   * whether account has been verified with billing information
   */
  verified?: boolean
}
/**
 * entity that owns this identity provider
 */
export interface Owner {
  [k: string]: unknown
  /**
   * unique identifier of the owner
   */
  id: string
  /**
   * name of the owner
   */
  name?: string
  /**
   * type of the owner
   */
  type: 'enterprise-account' | 'team'
}
/**
 * Add-on Actions are lifecycle operations for add-on provisioning and deprovisioning. They allow add-on providers to (de)provision add-ons in the background and then report back when (de)provisioning is complete.
 */
export interface AddOnAction {
  [k: string]: unknown
}
/**
 * An add-on attachment represents a connection between an app and an add-on that it has been given access to.
 */
export interface AddOnAttachment {
  [k: string]: unknown
  /**
   * identity of add-on
   */
  addon?: {
    /**
     * billing application associated with this add-on
     */
    app: {
      [k: string]: unknown
      /**
       * unique identifier of app
       */
      id?: string
      /**
       * unique name of app
       */
      name?: string
    }
    /**
     * unique identifier of add-on
     */
    id: string
    /**
     * globally unique name of the add-on
     */
    name: string
  }
  /**
   * application that is attached to add-on
   */
  app?: {
    [k: string]: unknown
    /**
     * unique identifier of app
     */
    id?: string
    /**
     * unique name of app
     */
    name?: string
  }
  /**
   * when add-on attachment was created
   */
  created_at?: string
  /**
   * unique identifier of this add-on attachment
   */
  id?: string
  /**
   * URL for add-on partners to write to an add-on's logs
   */
  log_input_url?: null | string
  /**
   * unique name for this add-on attachment to this app
   */
  name?: string
  /**
   * attachment namespace
   */
  namespace?: null | string
  /**
   * when add-on attachment was updated
   */
  updated_at?: string
  /**
   * URL for logging into web interface of add-on in attached app context
   */
  web_url?: null | string
}
/**
 * Configuration of an Add-on
 */
export interface AddOnConfig {
  [k: string]: unknown
  /**
   * unique name of the config
   */
  name?: string
  /**
   * value of the config
   */
  value?: null | string
}
/**
 * Add-on Plan Actions are Provider functionality for specific add-on installations
 */
export interface AddOnPlanAction {
  [k: string]: unknown
  /**
   * identifier of the action to take that is sent via SSO
   */
  action?: string
  /**
   * a unique identifier
   */
  id?: string
  /**
   * the display text shown in Dashboard
   */
  label?: string
  /**
   * if the action requires the user to own the app
   */
  requires_owner?: boolean
  /**
   * absolute URL to use instead of an action
   */
  url?: string
}
/**
 * Add-on region capabilities represent the relationship between an Add-on Service and a specific Region. Only Beta and GA add-ons are returned by these endpoints.
 */
export interface AddOnRegionCapability {
  [k: string]: unknown
  addon_service?: AddOnService
  /**
   * unique identifier of this add-on-region-capability
   */
  id?: string
  region?: Region
  /**
   * whether the add-on can be installed to a Space
   */
  supports_private_networking?: boolean
}
/**
 * Add-on services represent add-ons that may be provisioned for apps. Endpoints under add-on services can be accessed without authentication.
 */
export interface AddOnService {
  [k: string]: unknown
  /**
   * npm package name of the add-on service's Heroku CLI plugin
   */
  cli_plugin_name?: null | string
  /**
   * when add-on-service was created
   */
  created_at?: string
  /**
   * human-readable name of the add-on service provider
   */
  human_name?: string
  /**
   * unique identifier of this add-on-service
   */
  id?: string
  /**
   * unique name of this add-on-service
   */
  name?: string
  /**
   * release status for add-on service
   */
  state?: 'alpha' | 'beta' | 'ga' | 'shutdown'
  /**
   * whether or not apps can have access to more than one instance of this add-on at the same time
   */
  supports_multiple_installations?: boolean
  /**
   * whether or not apps can have access to add-ons billed to a different app
   */
  supports_sharing?: boolean
  /**
   * when add-on-service was updated
   */
  updated_at?: string
}
/**
 * A region represents a geographic location in which your application may run.
 */
export interface Region {
  [k: string]: unknown
  /**
   * country where the region exists
   */
  country?: string
  /**
   * when region was created
   */
  created_at?: string
  /**
   * description of region
   */
  description?: string
  /**
   * unique identifier of region
   */
  id?: string
  /**
   * area in the country where the region exists
   */
  locale?: string
  /**
   * unique name of region
   */
  name?: string
  /**
   * whether or not region is available for creating a Private Space
   */
  private_capable?: boolean
  provider?: Provider
  /**
   * when region was updated
   */
  updated_at?: string
}
/**
 * provider of underlying substrate
 */
export interface Provider {
  [k: string]: unknown
  /**
   * name of provider
   */
  name?: string
  /**
   * region name used by provider
   */
  region?:
    | 'ap-northeast-1'
    | 'ap-northeast-2'
    | 'ap-south-1'
    | 'ap-southeast-1'
    | 'ap-southeast-2'
    | 'ca-central-1'
    | 'eu-central-1'
    | 'eu-west-1'
    | 'eu-west-2'
    | 'sa-east-1'
    | 'us-east-1'
    | 'us-west-1'
    | 'us-west-2'
}
/**
 * Represents the delivery of a webhook notification, including its current status.
 */
export interface AddOnWebhookDelivery {
  [k: string]: unknown
}
/**
 * Represents a webhook event that occurred.
 */
export interface AddOnWebhookEvent {
  [k: string]: unknown
}
/**
 * Represents the details of a webhook subscription
 */
export interface AddOnWebhook {
  /**
   * when the webhook was created
   */
  created_at: string
  /**
   * the webhook's unique identifier
   */
  id: string
  include: Include
  /**
   * if `notify`, Heroku makes a single, fire-and-forget delivery attempt. If `sync`, Heroku attempts multiple deliveries until the request is successful or a limit is reached
   */
  level: 'notify' | 'sync'
  /**
   * when the webhook was updated
   */
  updated_at: string
  /**
   * the URL where the webhook's notification requests are sent
   */
  url: string
}
/**
 * Add-ons represent add-ons that have been provisioned and attached to one or more apps.
 */
export interface AddOn {
  actions: Actions
  /**
   * identity of add-on service
   */
  addon_service:
    | {
        [k: string]: unknown
        /**
         * unique identifier of this add-on-service
         */
        id?: string
        /**
         * unique name of this add-on-service
         */
        name?: string
      }
    | AddOnService
  /**
   * billing application associated with this add-on
   */
  app: {
    [k: string]: unknown
    /**
     * unique identifier of app
     */
    id?: string
    /**
     * unique name of app
     */
    name?: string
  }
  /**
   * billed price
   */
  billed_price: {
    [k: string]: unknown
    /**
     * price in cents per unit of plan
     */
    cents?: number
    /**
     * price is negotiated in a contract outside of monthly add-on billing
     */
    contract?: boolean
    /**
     * unit of price for plan
     */
    unit?: string
  } | null
  /**
   * billing entity associated with this add-on
   */
  billing_entity: {
    [k: string]: unknown
    /**
     * unique identifier of the billing entity
     */
    id?: string
    /**
     * name of the billing entity
     */
    name?: string
    /**
     * type of Object of the billing entity; new types allowed at any time.
     */
    type?: 'app' | 'team'
  }
  config_vars: AddonConfigVars
  /**
   * when add-on was created
   */
  created_at: string
  /**
   * unique identifier of add-on
   */
  id: string
  /**
   * globally unique name of the add-on
   */
  name: string
  /**
   * identity of add-on plan
   */
  plan:
    | {
        [k: string]: unknown
        /**
         * unique identifier of this plan
         */
        id?: string
        /**
         * unique name of this plan
         */
        name?: string
      }
    | Plan
  /**
   * id of this add-on with its provider
   */
  provider_id: string
  /**
   * A provision message
   */
  provision_message?: string
  /**
   * state in the add-on's lifecycle
   */
  state: 'deprovisioned' | 'provisioned' | 'provisioning'
  /**
   * when add-on was updated
   */
  updated_at: string
  /**
   * URL for logging into web interface of add-on (e.g. a dashboard)
   */
  web_url: null | string
}
/**
 * Plans represent different configurations of add-ons that may be added to apps. Endpoints under add-on services can be accessed without authentication.
 */
export interface Plan {
  [k: string]: unknown
  /**
   * identity of add-on service
   */
  addon_service?: {
    [k: string]: unknown
    /**
     * unique identifier of this add-on-service
     */
    id?: string
    /**
     * unique name of this add-on-service
     */
    name?: string
  }
  compliance?: Compliance
  /**
   * when plan was created
   */
  created_at?: string
  /**
   * whether this plan is the default for its add-on service
   */
  default?: boolean
  /**
   * description of plan
   */
  description?: string
  /**
   * human readable name of the add-on plan
   */
  human_name?: string
  /**
   * unique identifier of this plan
   */
  id?: string
  /**
   * whether this plan is installable to a Private Spaces app
   */
  installable_inside_private_network?: boolean
  /**
   * whether this plan is installable to a Common Runtime app
   */
  installable_outside_private_network?: boolean
  /**
   * unique name of this plan
   */
  name?: string
  /**
   * price
   */
  price?: {
    [k: string]: unknown
    /**
     * price in cents per unit of plan
     */
    cents?: number
    /**
     * price is negotiated in a contract outside of monthly add-on billing
     */
    contract?: boolean
    /**
     * unit of price for plan
     */
    unit?: string
  }
  /**
   * whether this plan is the default for apps in Private Spaces
   */
  space_default?: boolean
  /**
   * release status for plan
   */
  state?: string
  /**
   * when plan was updated
   */
  updated_at?: string
  /**
   * whether this plan is publicly visible
   */
  visible?: boolean
}
/**
 * Entities that have been allowed to be used by a Team
 */
export interface AllowedAddOnService {
  [k: string]: unknown
  /**
   * when the add-on service was allowed
   */
  added_at?: string
  added_by?: AddedBy
  addon_service?: AddonService
  /**
   * unique identifier for this allowed add-on service record
   */
  id?: string
}
/**
 * the user which allowed the add-on service
 */
export interface AddedBy {
  [k: string]: unknown
  /**
   * unique email address of account
   */
  email?: string
  /**
   * unique identifier of an account
   */
  id?: string
}
/**
 * the add-on service allowed for use
 */
export interface AddonService {
  [k: string]: unknown
  /**
   * human-readable name of the add-on service provider
   */
  human_name?: string
  /**
   * unique identifier of this add-on-service
   */
  id?: string
  /**
   * unique name of this add-on-service
   */
  name?: string
}
/**
 * An app feature represents a Heroku labs capability that can be enabled or disabled for an app on Heroku.
 */
export interface AppFeature {
  [k: string]: unknown
  /**
   * when app feature was created
   */
  created_at?: string
  /**
   * description of app feature
   */
  description?: string
  /**
   * user readable feature name
   */
  display_name?: string
  /**
   * documentation URL of app feature
   */
  doc_url?: string
  /**
   * whether or not app feature has been enabled
   */
  enabled?: boolean
  /**
   * e-mail to send feedback about the feature
   */
  feedback_email?: string
  /**
   * unique identifier of app feature
   */
  id?: string
  /**
   * unique name of app feature
   */
  name?: string
  /**
   * state of app feature
   */
  state?: string
  /**
   * when app feature was updated
   */
  updated_at?: string
}
/**
 * An app setup represents an app on Heroku that is setup using an environment, addons, and scripts described in an app.json manifest file.
 */
export interface AppSetup {
  [k: string]: unknown
  /**
   * identity of app
   */
  app?: {
    [k: string]: unknown
    /**
     * unique identifier of app
     */
    id?: string
    /**
     * unique name of app
     */
    name?: string
  }
  /**
   * identity and status of build
   */
  build?: {
    [k: string]: unknown
    /**
     * unique identifier of build
     */
    id?: string
    /**
     * Build process output will be available from this URL as a stream. The stream is available as either `text/plain` or `text/event-stream`. Clients should be prepared to handle disconnects and can resume the stream by sending a `Range` header (for `text/plain`) or a `Last-Event-Id` header (for `text/event-stream`).
     */
    output_stream_url?: string
    /**
     * status of build
     */
    status?: 'failed' | 'pending' | 'succeeded'
  } | null
  /**
   * when app setup was created
   */
  created_at?: string
  /**
   * reason that app setup has failed
   */
  failure_message?: null | string
  /**
   * unique identifier of app setup
   */
  id?: string
  manifest_errors?: ManifestErrors
  postdeploy?: Postdeploy
  /**
   * fully qualified success url
   */
  resolved_success_url?: null | string
  /**
   * the overall status of app setup
   */
  status?: 'failed' | 'pending' | 'succeeded'
  /**
   * when app setup was updated
   */
  updated_at?: string
}
/**
 * An app transfer represents a two party interaction for transferring ownership of an app.
 */
export interface AppTransfer {
  [k: string]: unknown
  /**
   * app involved in the transfer
   */
  app?: {
    [k: string]: unknown
    /**
     * unique identifier of app
     */
    id?: string
    /**
     * unique name of app
     */
    name?: string
  }
  /**
   * when app transfer was created
   */
  created_at?: string
  /**
   * unique identifier of app transfer
   */
  id?: string
  /**
   * identity of the owner of the transfer
   */
  owner?: {
    [k: string]: unknown
    /**
     * unique email address of account
     */
    email?: string
    /**
     * unique identifier of an account
     */
    id?: string
  }
  /**
   * identity of the recipient of the transfer
   */
  recipient?: {
    [k: string]: unknown
    /**
     * unique email address of account
     */
    email?: string
    /**
     * unique identifier of an account
     */
    id?: string
  }
  /**
   * the current state of an app transfer
   */
  state?: 'accepted' | 'declined' | 'pending'
  /**
   * when app transfer was updated
   */
  updated_at?: string
}
/**
 * Represents the delivery of a webhook notification, including its current status.
 */
export interface AppWebhookDelivery {
  [k: string]: unknown
  /**
   * when the delivery was created
   */
  created_at?: string
  /**
   * identity of event
   */
  event?: {
    [k: string]: unknown
    /**
     * the event's unique identifier
     */
    id?: string
    /**
     * the type of entity that the event is related to
     */
    include?: string
  }
  /**
   * the delivery's unique identifier
   */
  id?: string
  /**
   * last attempt of a delivery
   */
  last_attempt?: {
    [k: string]: unknown
    /**
     * http response code received during attempt
     */
    code?: null | number
    /**
     * when attempt was created
     */
    created_at?: string
    /**
     * error class encountered during attempt
     */
    error_class?: null | string
    /**
     * unique identifier of attempt
     */
    id?: string
    /**
     * status of an attempt
     */
    status?: 'failed' | 'scheduled' | 'succeeded'
    /**
     * when attempt was updated
     */
    updated_at?: string
  } | null
  /**
   * when delivery will be attempted again
   */
  next_attempt_at?: null | string
  /**
   * number of times a delivery has been attempted
   */
  num_attempts?: number
  /**
   * the delivery's status
   */
  status?: 'failed' | 'pending' | 'retrying' | 'scheduled' | 'succeeded'
  /**
   * when the delivery was last updated
   */
  updated_at?: string
  /**
   * identity of webhook
   */
  webhook?: {
    [k: string]: unknown
    /**
     * the webhook's unique identifier
     */
    id?: string
    /**
     * if `notify`, Heroku makes a single, fire-and-forget delivery attempt. If `sync`, Heroku attempts multiple deliveries until the request is successful or a limit is reached
     */
    level?: 'notify' | 'sync'
  }
}
/**
 * Represents a webhook event that occurred.
 */
export interface AppWebhookEvent {
  [k: string]: unknown
  /**
   * when event was created
   */
  created_at?: string
  /**
   * the event's unique identifier
   */
  id?: string
  /**
   * the type of entity that the event is related to
   */
  include?: string
  payload?: Payload
  /**
   * when the event was last updated
   */
  updated_at?: string
}
/**
 * payload of event
 */
export interface Payload {
  [k: string]: unknown
  /**
   * the type of event that occurred
   */
  action?: string
  actor?: Actor
  data?: Data
  previous_data?: PreviousData
  /**
   * the type of resource associated with the event
   */
  resource?: string
  /**
   * the version of the details provided for the event
   */
  version?: string
}
/**
 * user that caused event
 */
export interface Actor {
  [k: string]: unknown
  /**
   * unique email address of account
   */
  email?: string
  /**
   * unique identifier of an account
   */
  id?: string
}
/**
 * the current details of the event
 */
export interface Data {
  [k: string]: unknown
}
/**
 * previous details of the event (if any)
 */
export interface PreviousData {
  [k: string]: unknown
}
/**
 * Represents the details of a webhook subscription
 */
export interface AppWebhook {}
/**
 * An app represents the program that you would like to deploy and run on Heroku.
 */
export interface App {
  [k: string]: unknown
  /**
   * ACM status of this app
   */
  acm?: boolean
  /**
   * when app was archived
   */
  archived_at?: null | string
  /**
   * identity of the stack that will be used for new builds
   */
  build_stack?: {
    [k: string]: unknown
    /**
     * unique identifier of stack
     */
    id?: string
    /**
     * unique name of stack
     */
    name?: string
  }
  /**
   * description from buildpack of app
   */
  buildpack_provided_description?: null | string
  /**
   * when app was created
   */
  created_at?: string
  /**
   * git repo URL of app
   */
  git_url?: string
  /**
   * unique identifier of app
   */
  id?: string
  /**
   * describes whether a Private Spaces app is externally routable or not
   */
  internal_routing?: boolean | null
  /**
   * maintenance status of app
   */
  maintenance?: boolean
  /**
   * unique name of app
   */
  name?: string
  /**
   * identity of team
   */
  organization?: {
    [k: string]: unknown
    /**
     * unique identifier of team
     */
    id?: string
    /**
     * unique name of team
     */
    name?: string
  } | null
  /**
   * identity of app owner
   */
  owner?: {
    [k: string]: unknown
    /**
     * unique email address of account
     */
    email?: string
    /**
     * unique identifier of an account
     */
    id?: string
  }
  /**
   * identity of app region
   */
  region?: {
    [k: string]: unknown
    /**
     * unique identifier of region
     */
    id?: string
    /**
     * unique name of region
     */
    name?: string
  }
  /**
   * when app was released
   */
  released_at?: null | string
  /**
   * git repo size in bytes of app
   */
  repo_size?: null | number
  /**
   * slug size in bytes of app
   */
  slug_size?: null | number
  /**
   * identity of space
   */
  space?: {
    [k: string]: unknown
    /**
     * unique identifier of space
     */
    id?: string
    /**
     * unique name of space
     */
    name?: string
    /**
     * true if this space has shield enabled
     */
    shield?: boolean
  } | null
  /**
   * identity of app stack
   */
  stack?: {
    [k: string]: unknown
    /**
     * unique identifier of stack
     */
    id?: string
    /**
     * unique name of stack
     */
    name?: string
  }
  /**
   * identity of team
   */
  team?: {
    [k: string]: unknown
    /**
     * unique identifier of team
     */
    id?: string
    /**
     * unique name of team
     */
    name?: string
  } | null
  /**
   * when app was updated
   */
  updated_at?: string
  /**
   * web URL of app
   */
  web_url?: null | string
}
/**
 * An audit trail archive represents a monthly json zipped file containing events
 */
export interface AuditTrailArchive {
  [k: string]: unknown
  /**
   * checksum for the archive
   */
  checksum?: string
  /**
   * when archive was created
   */
  created_at?: string
  /**
   * month of the archive
   */
  month?: '01' | '02' | '03' | '04' | '05' | '06' | '07' | '08' | '09' | '10' | '11' | '12'
  /**
   * size of the archive in bytes
   */
  size?: number
  /**
   * url where to download the archive
   */
  url?: string
  /**
   * year of the archive
   */
  year?: number
}
/**
 * An audit trail event represents some action on the platform
 */
export interface AuditTrailEvent {
  [k: string]: unknown
  /**
   * action for the event
   */
  action?: string
  actor?: Actor1
  app?: AuditTrailApp
  /**
   * when event was created
   */
  created_at?: string
  data?: Data1
  enterprise_account?: EnterpriseAccount
  /**
   * unique identifier of event
   */
  id?: string
  owner?: Owner1
  request?: Request
  team?: Team
  /**
   * type of event
   */
  type?: string
}
/**
 * user who caused event
 */
export interface Actor1 {
  [k: string]: unknown
  email?: string
  id?: string
}
/**
 * app upon which event took place
 */
export interface AuditTrailApp {
  [k: string]: unknown
  id?: string
  name?: string
}
/**
 * owner of the app targeted by the event
 */
export interface Owner1 {
  [k: string]: unknown
  email?: string
  id?: string
}
/**
 * enterprise account on which the event happened
 */
export interface EnterpriseAccount {
  [k: string]: unknown
  id?: string
  name?: string
}
/**
 * team on which the event happened
 */
export interface Team {
  [k: string]: unknown
  id?: string
  name?: string
}
/**
 * information about where the action was triggered
 */
export interface Request {
  [k: string]: unknown
  ip_address?: string
}
/**
 * data specific to the event
 */
export interface Data1 {
  [k: string]: unknown
}
/**
 * A build represents the process of transforming a code tarball into a slug
 */
export interface Build {
  [k: string]: unknown
  /**
   * app that the build belongs to
   */
  app?: {
    [k: string]: unknown
    /**
     * unique identifier of app
     */
    id?: string
  }
  buildpacks?: Buildpacks
  /**
   * when build was created
   */
  created_at: string
  /**
   * unique identifier of build
   */
  id: string
  /**
   * Build process output will be available from this URL as a stream. The stream is available as either `text/plain` or `text/event-stream`. Clients should be prepared to handle disconnects and can resume the stream by sending a `Range` header (for `text/plain`) or a `Last-Event-Id` header (for `text/event-stream`).
   */
  output_stream_url?: string
  release?: BuildRelease
  /**
   * slug created by this build
   */
  slug?: {
    [k: string]: unknown
    /**
     * unique identifier of slug
     */
    id?: string
  } | null
  source_blob: SourceBlob
  /**
   * stack of build
   */
  stack?: string
  /**
   * status of build
   */
  status: 'failed' | 'pending' | 'succeeded'
  /**
   * when build was updated
   */
  updated_at: string
  /**
   * user that started the build
   */
  user: {
    [k: string]: unknown
    /**
     * unique email address of account
     */
    email?: string
    /**
     * unique identifier of an account
     */
    id?: string
  }
}
/**
 * location of gzipped tarball of source code used to create build
 */
export interface SourceBlob {
  [k: string]: unknown
  /**
   * an optional checksum of the gzipped tarball for verifying its integrity
   */
  checksum?: null | string
  /**
   * URL where gzipped tar archive of source code for build was downloaded.
   */
  url?: string
  /**
   * Version of the gzipped tarball.
   */
  version?: null | string
  /**
   * Version description of the gzipped tarball.
   */
  version_description?: null | string
}
/**
 * A buildpack installation represents a buildpack that will be run against an app.
 */
export interface BuildpackInstallations {
  [k: string]: unknown
  /**
   * buildpack
   */
  buildpack?: {
    [k: string]: unknown
    /**
     * either the Buildpack Registry name or a URL of the buildpack for the app
     */
    name?: string
    /**
     * location of the buildpack for the app. Either a url (unofficial buildpacks) or an internal urn (heroku official buildpacks).
     */
    url?: string
  }
  /**
   * determines the order in which the buildpacks will execute
   */
  ordinal?: number
}
/**
 * A collaborator represents an account that has been given access to an app on Heroku.
 */
export interface Collaborator {
  /**
   * app collaborator belongs to
   */
  app: {
    [k: string]: unknown
    /**
     * unique identifier of app
     */
    id?: string
    /**
     * unique name of app
     */
    name?: string
  }
  /**
   * when collaborator was created
   */
  created_at: string
  /**
   * unique identifier of collaborator
   */
  id: string
  permissions?: TeamAppPermission[]
  /**
   * role in the team
   */
  role?: 'admin' | 'collaborator' | 'member' | 'owner' | null
  /**
   * when collaborator was updated
   */
  updated_at: string
  /**
   * identity of collaborated account
   */
  user: {
    [k: string]: unknown
    /**
     * unique email address of account
     */
    email?: string
    /**
     * whether the user is federated and belongs to an Identity Provider
     */
    federated?: boolean
    /**
     * unique identifier of an account
     */
    id?: string
  }
}
/**
 * A team app permission is a behavior that is assigned to a user in a team app.
 */
export interface TeamAppPermission {
  [k: string]: unknown
  /**
   * A description of what the app permission allows.
   */
  description?: string
  /**
   * The name of the app permission.
   */
  name?: string
}
/**
 * Config Vars allow you to manage the configuration information provided to an app on Heroku.
 */
export interface ConfigVars {
  /**
   * This interface was referenced by `ConfigVars`'s JSON-Schema definition
   * via the `patternProperty` "^\w+$".
   */
  [k: string]: string
}
/**
 * A credit represents value that will be used up before further charges are assigned to an account.
 */
export interface Credit {
  [k: string]: unknown
  /**
   * total value of credit in cents
   */
  amount?: number
  /**
   * remaining value of credit in cents
   */
  balance?: number
  /**
   * when credit was created
   */
  created_at?: string
  /**
   * when credit will expire
   */
  expires_at?: string
  /**
   * unique identifier of credit
   */
  id?: string
  /**
   * a name for credit
   */
  title?: string
  /**
   * when credit was updated
   */
  updated_at?: string
}
/**
 * Domains define what web routes should be routed to an app on Heroku.
 */
export interface Domain {
  [k: string]: unknown
  /**
   * status of this record's ACM
   */
  acm_status?: null | string
  /**
   * reason for the status of this record's ACM
   */
  acm_status_reason?: null | string
  /**
   * app that owns the domain
   */
  app?: {
    [k: string]: unknown
    /**
     * unique identifier of app
     */
    id?: string
    /**
     * unique name of app
     */
    name?: string
  }
  /**
   * canonical name record, the address to point a domain at
   */
  cname?: null | string
  /**
   * when domain was created
   */
  created_at?: string
  /**
   * full hostname
   */
  hostname?: string
  /**
   * unique identifier of this domain
   */
  id?: string
  /**
   * type of domain name
   */
  kind?: 'custom' | 'heroku'
  /**
   * sni endpoint the domain is associated with
   */
  sni_endpoint?: {
    [k: string]: unknown
    /**
     * unique identifier of this SNI endpoint
     */
    id?: string
    /**
     * unique name for SNI endpoint
     */
    name?: string
  } | null
  /**
   * status of this record's cname
   */
  status?: string
  /**
   * when domain was updated
   */
  updated_at?: string
}
/**
 * Dyno sizes are the values and details of sizes that can be assigned to dynos. This information can also be found at : [https://devcenter.heroku.com/articles/dyno-types](https://devcenter.heroku.com/articles/dyno-types).
 */
export interface DynoSize {
  [k: string]: unknown
  /**
   * minimum vCPUs, non-dedicated may get more depending on load
   */
  compute?: number
  cost?: Cost
  /**
   * whether this dyno will be dedicated to one user
   */
  dedicated?: boolean
  /**
   * @deprecated
   * deprecated. See precise_dyno_units instead
   */
  dyno_units?: number
  /**
   * unique identifier of this dyno size
   */
  id?: string
  /**
   * amount of RAM in GB
   */
  memory?: number
  /**
   * the name of this dyno-size
   */
  name?: string
  /**
   * unit of consumption for Heroku Enterprise customers to 2 decimal places
   */
  precise_dyno_units?: number
  /**
   * whether this dyno can only be provisioned in a private space
   */
  private_space_only?: boolean
}
/**
 * Dynos encapsulate running processes of an app on Heroku. Detailed information about dyno sizes can be found at: [https://devcenter.heroku.com/articles/dyno-types](https://devcenter.heroku.com/articles/dyno-types).
 */
export interface Dyno {
  [k: string]: unknown
  /**
   * app formation belongs to
   */
  app?: {
    [k: string]: unknown
    /**
     * unique identifier of app
     */
    id?: string
    /**
     * unique name of app
     */
    name?: string
  }
  /**
   * a URL to stream output from for attached processes or null for non-attached processes
   */
  attach_url?: null | string
  /**
   * command used to start this process
   */
  command?: string
  /**
   * when dyno was created
   */
  created_at?: string
  /**
   * unique identifier of this dyno
   */
  id?: string
  /**
   * the name of this process on this dyno
   */
  name?: string
  /**
   * app release of the dyno
   */
  release?: {
    [k: string]: unknown
    /**
     * unique identifier of release
     */
    id?: string
    /**
     * unique version assigned to the release
     */
    version?: number
  }
  /**
   * dyno size
   */
  size?: string
  /**
   * current status of process (either: crashed, down, idle, starting, or up)
   */
  state?: string
  /**
   * type of process
   */
  type?: string
  /**
   * when process last changed state
   */
  updated_at?: string
}
/**
 * Usage for an enterprise account at a daily resolution.
 */
export interface EnterpriseAccountDailyUsage {
  [k: string]: unknown
  /**
   * total add-on credits used
   */
  addons?: number
  /**
   * total add-on credits used for first party add-ons
   */
  data?: number
  /**
   * date of the usage
   */
  date?: string
  /**
   * dynos used
   */
  dynos?: number
  /**
   * enterprise account identifier
   */
  id?: string
  /**
   * name of the enterprise account
   */
  name?: string
  /**
   * total add-on credits used for third party add-ons
   */
  partner?: number
  /**
   * space credits used
   */
  space?: number
  /**
   * usage by team
   */
  teams?: {
    [k: string]: unknown
    /**
     * total add-on credits used
     */
    addons?: number
    /**
     * app usage in the team
     */
    apps?: AppUsageDaily[]
    /**
     * total add-on credits used for first party add-ons
     */
    data?: number
    /**
     * dynos used
     */
    dynos?: number
    /**
     * team identifier
     */
    id?: string
    /**
     * name of the team
     */
    name?: string
    /**
     * total add-on credits used for third party add-ons
     */
    partner?: number
    /**
     * space credits used
     */
    space?: number
  }[]
}
/**
 * Usage for an app at a daily resolution.
 */
export interface AppUsageDaily {
  [k: string]: unknown
  /**
   * total add-on credits used
   */
  addons?: number
  /**
   * unique name of app
   */
  app_name?: string
  /**
   * total add-on credits used for first party add-ons
   */
  data?: number
  /**
   * dynos used
   */
  dynos?: number
  /**
   * total add-on credits used for third party add-ons
   */
  partner?: number
}
/**
 * Enterprise account members are users with access to an enterprise account.
 */
export interface EnterpriseAccountMember {
  [k: string]: unknown
  enterprise_account?: {
    [k: string]: unknown
    /**
     * unique identifier of the enterprise account
     */
    id?: string
    /**
     * unique name of the enterprise account
     */
    name?: string
  }
  /**
   * unique identifier of the member
   */
  id?: string
  identity_provider?: MemberIdentityProvider
  permissions?: ExpandedPermissions
  /**
   * whether the Enterprise Account member has two factor authentication enabled
   */
  two_factor_authentication?: boolean
  /**
   * user information for the membership
   */
  user?: {
    [k: string]: unknown
    /**
     * unique email address of account
     */
    email?: string
    /**
     * unique identifier of an account
     */
    id?: string
  }
}
/**
 * Usage for an enterprise account at a monthly resolution.
 */
export interface EnterpriseAccountMonthlyUsage {
  [k: string]: unknown
  /**
   * total add-on credits used
   */
  addons?: number
  /**
   * average connect rows synced
   */
  connect?: number
  /**
   * total add-on credits used for first party add-ons
   */
  data?: number
  /**
   * dynos used
   */
  dynos?: number
  /**
   * enterprise account identifier
   */
  id?: string
  /**
   * year and month of the usage
   */
  month?: string
  /**
   * name of the enterprise account
   */
  name?: string
  /**
   * total add-on credits used for third party add-ons
   */
  partner?: number
  /**
   * space credits used
   */
  space?: number
  /**
   * usage by team
   */
  teams?: {
    [k: string]: unknown
    /**
     * total add-on credits used
     */
    addons?: number
    /**
     * app usage in the team
     */
    apps?: AppUsageMonthly[]
    /**
     * average connect rows synced
     */
    connect?: number
    /**
     * total add-on credits used for first party add-ons
     */
    data?: number
    /**
     * dynos used
     */
    dynos?: number
    /**
     * team identifier
     */
    id?: string
    /**
     * name of the team
     */
    name?: string
    /**
     * total add-on credits used for third party add-ons
     */
    partner?: number
    /**
     * space credits used
     */
    space?: number
  }[]
}
/**
 * Usage for an app at a monthly resolution.
 */
export interface AppUsageMonthly {
  [k: string]: unknown
  /**
   * total add-on credits used
   */
  addons?: number
  /**
   * unique name of app
   */
  app_name?: string
  /**
   * total add-on credits used for first party add-ons
   */
  data?: number
  /**
   * dynos used
   */
  dynos?: number
  /**
   * total add-on credits used for third party add-ons
   */
  partner?: number
}
/**
 * Enterprise accounts allow companies to manage their development teams and billing.
 */
export interface EnterpriseAccount {
  [k: string]: unknown
  /**
   * when the enterprise account was created
   */
  created_at?: string
  /**
   * unique identifier of the enterprise account
   */
  id?: string
  identity_provider?: IdentityProvider1
  /**
   * unique name of the enterprise account
   */
  name?: string
  permissions?: Permissions
  /**
   * whether the enterprise account is a trial or not
   */
  trial?: boolean
  /**
   * when the enterprise account was updated
   */
  updated_at?: string
}
/**
 * Filters are special endpoints to allow for API consumers to specify a subset of resources to consume in order to reduce the number of requests that are performed.  Each filter endpoint endpoint is responsible for determining its supported request format.  The endpoints are over POST in order to handle large request bodies without hitting request uri query length limitations, but the requests themselves are idempotent and will not have side effects.
 */
export interface Filters {
  [k: string]: unknown
}
/**
 * The formation of processes that should be maintained for an app. Update the formation to scale processes or change dyno sizes. Available process type names and commands are defined by the `process_types` attribute for the [slug](#slug) currently released on an app.
 */
export interface Formation {
  [k: string]: unknown
  /**
   * app formation belongs to
   */
  app?: {
    [k: string]: unknown
    /**
     * unique identifier of app
     */
    id?: string
    /**
     * unique name of app
     */
    name?: string
  }
  /**
   * command to use to launch this process
   */
  command?: string
  /**
   * when process type was created
   */
  created_at?: string
  /**
   * unique identifier of this process type
   */
  id?: string
  /**
   * number of processes to maintain
   */
  quantity?: number
  /**
   * dyno size
   */
  size?: string
  /**
   * type of process to maintain
   */
  type?: string
  /**
   * when dyno type was updated
   */
  updated_at?: string
}
/**
 * Identity Providers represent the SAML configuration of teams or an Enterprise account
 */
export interface IdentityProvider {
  [k: string]: unknown
  /**
   * raw contents of the public certificate (eg: .crt or .pem file)
   */
  certificate?: string
  /**
   * when provider record was created
   */
  created_at?: string
  /**
   * URL identifier provided by the identity provider
   */
  entity_id?: string
  /**
   * unique identifier of this identity provider
   */
  id?: string
  /**
   * team associated with this identity provider
   */
  organization?: {
    [k: string]: unknown
    /**
     * unique name of team
     */
    name?: string
  } | null
  owner?: Owner
  /**
   * single log out URL for this identity provider
   */
  slo_target_url?: string
  /**
   * single sign on URL for this identity provider
   */
  sso_target_url?: string
  /**
   * when the identity provider record was updated
   */
  updated_at?: string
}
/**
 * An inbound-ruleset is a collection of rules that specify what hosts can or cannot connect to an application.
 */
export interface InboundRuleset {
  [k: string]: unknown
  /**
   * when inbound-ruleset was created
   */
  created_at?: string
  /**
   * unique email address of account
   */
  created_by?: string
  /**
   * unique identifier of an inbound-ruleset
   */
  id?: string
  rules?: Rule[]
  /**
   * identity of space
   */
  space?: {
    [k: string]: unknown
    /**
     * unique identifier of space
     */
    id?: string
    /**
     * unique name of space
     */
    name?: string
  }
}
/**
 * the combination of an IP address in CIDR notation and whether to allow or deny it's traffic.
 */
export interface Rule {
  [k: string]: unknown
  /**
   * states whether the connection is allowed or denied
   */
  action: 'allow' | 'deny'
  /**
   * is the requests source in CIDR notation
   */
  source: string
}
/**
 * An invoice address represents the address that should be listed on an invoice.
 */
export interface InvoiceAddress {
  [k: string]: unknown
  /**
   * invoice street address line 1
   */
  address_1?: string
  /**
   * invoice street address line 2
   */
  address_2?: string
  /**
   * invoice city
   */
  city?: string
  /**
   * country
   */
  country?: string
  heroku_id?: string
  /**
   * metadata / additional information to go on invoice
   */
  other?: string
  /**
   * invoice zip code
   */
  postal_code?: string
  /**
   * invoice state
   */
  state?: string
  /**
   * flag to use the invoice address for an account or not
   */
  use_invoice_address?: boolean
}
/**
 * An invoice is an itemized bill of goods for an account which includes pricing and charges.
 */
export interface Invoice {
  [k: string]: unknown
  /**
   * total charges on this invoice
   */
  charges_total?: number
  /**
   * when invoice was created
   */
  created_at?: string
  /**
   * total credits on this invoice
   */
  credits_total?: number
  /**
   * unique identifier of this invoice
   */
  id?: string
  /**
   * human readable invoice number
   */
  number?: number
  /**
   * the ending date that the invoice covers
   */
  period_end?: string
  /**
   * the starting date that this invoice covers
   */
  period_start?: string
  /**
   * payment status for this invoice (pending, successful, failed)
   */
  state?: number
  /**
   * combined total of charges and credits on this invoice
   */
  total?: number
  /**
   * when invoice was updated
   */
  updated_at?: string
}
/**
 * Keys represent public SSH keys associated with an account and are used to authorize accounts as they are performing git operations.
 */
export interface Key {
  [k: string]: unknown
  /**
   * comment on the key
   */
  comment?: string
  /**
   * when key was created
   */
  created_at?: string
  /**
   * @deprecated
   * deprecated. Please refer to 'comment' instead
   */
  email?: string
  /**
   * a unique identifying string based on contents
   */
  fingerprint?: string
  /**
   * unique identifier of this key
   */
  id?: string
  /**
   * full public_key as uploaded
   */
  public_key?: string
  /**
   * when key was updated
   */
  updated_at?: string
}
/**
 * [Log drains](https://devcenter.heroku.com/articles/log-drains) provide a way to forward your Heroku logs to an external syslog server for long-term archiving. This external service must be configured to receive syslog packets from Heroku, whereupon its URL can be added to an app using this API. Some add-ons will add a log drain when they are provisioned to an app. These drains can only be removed by removing the add-on.
 */
export interface LogDrain {
  [k: string]: unknown
  addon?: Addon
  app?: App1
  /**
   * when log drain was created
   */
  created_at?: string
  /**
   * unique identifier of this log drain
   */
  id?: string
  /**
   * token associated with the log drain
   */
  token?: string
  /**
   * when log drain was updated
   */
  updated_at?: string
  /**
   * url associated with the log drain
   */
  url?: string
}
/**
 * A log session is a reference to the http based log stream for an app.
 */
export interface LogSession {
  [k: string]: unknown
  /**
   * when log connection was created
   */
  created_at?: string
  /**
   * unique identifier of this log session
   */
  id?: string
  /**
   * URL for log streaming session
   */
  logplex_url?: string
  /**
   * when log session was updated
   */
  updated_at?: string
}
/**
 * OAuth authorizations represent clients that a Heroku user has authorized to automate, customize or extend their usage of the platform. For more information please refer to the [Heroku OAuth documentation](https://devcenter.heroku.com/articles/oauth)
 */
export interface OAuthAuthorization {
  [k: string]: unknown
  /**
   * access token for this authorization
   */
  access_token?: {
    [k: string]: unknown
    /**
     * seconds until OAuth token expires; may be `null` for tokens with indefinite lifetime
     */
    expires_in?: null | number
    /**
     * unique identifier of OAuth token
     */
    id?: string
    /**
     * contents of the token to be used for authorization
     */
    token?: string
  } | null
  /**
   * identifier of the client that obtained this authorization, if any
   */
  client?: {
    [k: string]: unknown
    /**
     * unique identifier of this OAuth client
     */
    id?: string
    /**
     * OAuth client name
     */
    name?: string
    /**
     * endpoint for redirection after authorization with OAuth client
     */
    redirect_uri?: string
  } | null
  /**
   * when OAuth authorization was created
   */
  created_at?: string
  /**
   * this authorization's grant
   */
  grant?: {
    [k: string]: unknown
    /**
     * grant code received from OAuth web application authorization
     */
    code?: string
    /**
     * seconds until OAuth grant expires
     */
    expires_in?: number
    /**
     * unique identifier of OAuth grant
     */
    id?: string
  } | null
  /**
   * unique identifier of OAuth authorization
   */
  id?: string
  /**
   * refresh token for this authorization
   */
  refresh_token?: {
    [k: string]: unknown
    /**
     * seconds until OAuth token expires; may be `null` for tokens with indefinite lifetime
     */
    expires_in?: null | number
    /**
     * unique identifier of OAuth token
     */
    id?: string
    /**
     * contents of the token to be used for authorization
     */
    token?: string
  } | null
  scope?: Scope
  /**
   * when OAuth authorization was updated
   */
  updated_at?: string
  /**
   * authenticated user associated with this authorization
   */
  user?: {
    [k: string]: unknown
    /**
     * unique email address of account
     */
    email?: string
    /**
     * full name of the account owner
     */
    full_name?: null | string
    /**
     * unique identifier of an account
     */
    id?: string
  }
}
/**
 * OAuth clients are applications that Heroku users can authorize to automate, customize or extend their usage of the platform. For more information please refer to the [Heroku OAuth documentation](https://devcenter.heroku.com/articles/oauth).
 */
export interface OAuthClient {
  [k: string]: unknown
  /**
   * when OAuth client was created
   */
  created_at?: string
  /**
   * unique identifier of this OAuth client
   */
  id?: string
  /**
   * whether the client is still operable given a delinquent account
   */
  ignores_delinquent?: boolean | null
  /**
   * OAuth client name
   */
  name?: string
  /**
   * endpoint for redirection after authorization with OAuth client
   */
  redirect_uri?: string
  /**
   * secret used to obtain OAuth authorizations under this client
   */
  secret?: string
  /**
   * when OAuth client was updated
   */
  updated_at?: string
}
/**
 * OAuth grants are used to obtain authorizations on behalf of a user. For more information please refer to the [Heroku OAuth documentation](https://devcenter.heroku.com/articles/oauth)
 */
export interface OAuthGrant {
  [k: string]: unknown
}
/**
 * OAuth tokens provide access for authorized clients to act on behalf of a Heroku user to automate, customize or extend their usage of the platform. For more information please refer to the [Heroku OAuth documentation](https://devcenter.heroku.com/articles/oauth)
 */
export interface OAuthToken {
  [k: string]: unknown
  /**
   * current access token
   */
  access_token?: {
    [k: string]: unknown
    /**
     * seconds until OAuth token expires; may be `null` for tokens with indefinite lifetime
     */
    expires_in?: null | number
    /**
     * unique identifier of OAuth token
     */
    id?: string
    /**
     * contents of the token to be used for authorization
     */
    token?: string
  }
  /**
   * authorization for this set of tokens
   */
  authorization?: {
    [k: string]: unknown
    /**
     * unique identifier of OAuth authorization
     */
    id?: string
  }
  /**
   * OAuth client secret used to obtain token
   */
  client?: {
    [k: string]: unknown
    /**
     * secret used to obtain OAuth authorizations under this client
     */
    secret?: string
  } | null
  /**
   * when OAuth token was created
   */
  created_at?: string
  /**
   * grant used on the underlying authorization
   */
  grant?: {
    [k: string]: unknown
    /**
     * grant code received from OAuth web application authorization
     */
    code?: string
    /**
     * type of grant requested, one of `authorization_code` or `refresh_token`
     */
    type?: string
  }
  /**
   * unique identifier of OAuth token
   */
  id?: string
  /**
   * refresh token for this authorization
   */
  refresh_token?: {
    [k: string]: unknown
    /**
     * seconds until OAuth token expires; may be `null` for tokens with indefinite lifetime
     */
    expires_in?: null | number
    /**
     * unique identifier of OAuth token
     */
    id?: string
    /**
     * contents of the token to be used for authorization
     */
    token?: string
  }
  /**
   * OAuth session using this token
   */
  session?: {
    [k: string]: unknown
    /**
     * unique identifier of OAuth token
     */
    id?: string
  }
  /**
   * when OAuth token was updated
   */
  updated_at?: string
  /**
   * Reference to the user associated with this token
   */
  user?: {
    [k: string]: unknown
    /**
     * unique identifier of an account
     */
    id?: string
  }
}
/**
 * A password reset represents a in-process password reset attempt.
 */
export interface PasswordReset {
  [k: string]: unknown
  /**
   * when password reset was created
   */
  created_at?: string
  user?: {
    [k: string]: unknown
    /**
     * unique email address of account
     */
    email?: string
    /**
     * unique identifier of an account
     */
    id?: string
  }
}
/**
 * [Peering Info](https://devcenter.heroku.com/articles/private-space-peering) gives you the information necessary to peer an AWS VPC to a Private Space.
 */
export interface PeeringInfo {
  [k: string]: unknown
  /**
   * The AWS account ID of your Private Space.
   */
  aws_account_id?: string
  /**
   * region name used by provider
   */
  aws_region?:
    | 'ap-northeast-1'
    | 'ap-northeast-2'
    | 'ap-south-1'
    | 'ap-southeast-1'
    | 'ap-southeast-2'
    | 'ca-central-1'
    | 'eu-central-1'
    | 'eu-west-1'
    | 'eu-west-2'
    | 'sa-east-1'
    | 'us-east-1'
    | 'us-west-1'
    | 'us-west-2'
  /**
   * The CIDR ranges that should be routed to the Private Space VPC.
   */
  dyno_cidr_blocks?: string[]
  /**
   * The CIDR ranges that should be routed to the Private Space VPC.
   */
  space_cidr_blocks?: string[]
  /**
   * The CIDR ranges that you must not conflict with.
   */
  unavailable_cidr_blocks?: string[]
  /**
   * The CIDR range of the Private Space VPC
   */
  vpc_cidr?: string
  /**
   * The AWS VPC ID of the peer.
   */
  vpc_id?: string
}
/**
 * [Peering](https://devcenter.heroku.com/articles/private-space-peering) provides a way to peer your Private Space VPC to another AWS VPC.
 */
export interface Peering {
  [k: string]: unknown
  /**
   * The AWS account ID of your Private Space.
   */
  aws_account_id?: string
  /**
   * The AWS region of the peer connection.
   */
  aws_region?: string
  /**
   * The AWS VPC ID of the peer.
   */
  aws_vpc_id?: string
  /**
   * The CIDR blocks of the peer.
   */
  cidr_blocks?: string[]
  /**
   * When a peering connection will expire.
   */
  expires?: string
  /**
   * The AWS VPC Peering Connection ID of the peering.
   */
  pcx_id?: string
  /**
   * The status of the peering connection.
   */
  status?:
    | 'active'
    | 'deleted'
    | 'expired'
    | 'failed'
    | 'initiating-request'
    | 'pending-acceptance'
    | 'provisioning'
    | 'rejected'
  /**
   * The type of peering connection.
   */
  type?: 'customer-managed' | 'heroku-managed' | 'unknown'
}
/**
 * An owned entity including users' permissions.
 */
export interface PermissionEntity {
  [k: string]: unknown
  /**
   * ID of the entity.
   */
  id?: string
  /**
   * Name of the entity.
   */
  name?: string
  /**
   * unique identifier of team
   */
  team_id?: string
  /**
   * The type of object the entity is referring to.
   */
  type?: 'app' | 'space'
  /**
   * Users that have access to the entity.
   */
  users?: {
    [k: string]: unknown
    /**
     * unique email address of account
     */
    email?: string
    /**
     * unique identifier of an account
     */
    id?: string
    /**
     * enterprise account permissions
     */
    permissions?: string[]
  }[]
}
/**
 * Information about latest builds of apps in a pipeline.
 */
export interface PipelineBuild {
  [k: string]: unknown
}
/**
 * Pipeline Config Vars allow you to manage the configuration information provided to a pipeline.
 */
export interface PipelineConfigVars {
  /**
   * This interface was referenced by `PipelineConfigVars`'s JSON-Schema definition
   * via the `patternProperty` "^\w+$".
   */
  [k: string]: string
}
/**
 * Information about an app's coupling to a pipeline
 */
export interface PipelineCoupling {
  [k: string]: unknown
  /**
   * app involved in the pipeline coupling
   */
  app?: {
    [k: string]: unknown
    /**
     * unique identifier of app
     */
    id?: string
  }
  /**
   * when pipeline coupling was created
   */
  created_at?: string
  /**
   * unique identifier of pipeline coupling
   */
  id?: string
  /**
   * pipeline involved in the coupling
   */
  pipeline?: {
    [k: string]: unknown
    /**
     * unique identifier of pipeline
     */
    id?: string
  }
  /**
   * target pipeline stage
   */
  stage?: 'development' | 'production' | 'review' | 'staging' | 'test'
  /**
   * when pipeline coupling was updated
   */
  updated_at?: string
}
/**
 * Information about latest deployments of apps in a pipeline.
 */
export interface PipelineDeployment {
  [k: string]: unknown
}
/**
 * Promotion targets represent an individual app being promoted to
 */
export interface PipelinePromotionTarget {
  [k: string]: unknown
  /**
   * the app which was promoted to
   */
  app?: {
    [k: string]: unknown
    /**
     * unique identifier of app
     */
    id?: string
  }
  /**
   * an error message for why the promotion failed
   */
  error_message?: null | string
  /**
   * unique identifier of promotion target
   */
  id?: string
  /**
   * the promotion which the target belongs to
   */
  pipeline_promotion?: {
    [k: string]: unknown
    /**
     * unique identifier of promotion
     */
    id?: string
  }
  /**
   * the release which was created on the target app
   */
  release?: {
    [k: string]: unknown
    /**
     * unique identifier of release
     */
    id?: string
  } | null
  /**
   * status of promotion
   */
  status?: 'failed' | 'pending' | 'succeeded'
}
/**
 * Promotions allow you to move code from an app in a pipeline to all targets
 */
export interface PipelinePromotion {
  [k: string]: unknown
  /**
   * when promotion was created
   */
  created_at?: string
  /**
   * unique identifier of promotion
   */
  id?: string
  /**
   * the pipeline which the promotion belongs to
   */
  pipeline?: {
    [k: string]: unknown
    /**
     * unique identifier of pipeline
     */
    id?: string
  }
  /**
   * the app being promoted from
   */
  source?: {
    [k: string]: unknown
    /**
     * the app which was promoted from
     */
    app?: {
      [k: string]: unknown
      /**
       * unique identifier of app
       */
      id?: string
    }
    /**
     * the release used to promoted from
     */
    release?: {
      [k: string]: unknown
      /**
       * unique identifier of release
       */
      id?: string
    }
  }
  /**
   * status of promotion
   */
  status?: 'completed' | 'pending'
  /**
   * when promotion was updated
   */
  updated_at?: null | string
}
/**
 * Information about latest releases of apps in a pipeline.
 */
export interface PipelineRelease {
  [k: string]: unknown
}
/**
 * A pipeline's stack is determined by the apps in the pipeline. This is used during creation of CI and Review Apps that have no stack defined in app.json
 */
export interface PipelineStack {
  [k: string]: unknown
  /**
   * identity of the stack that will be used for new builds without a stack defined in CI and Review Apps
   */
  stack?: {
    [k: string]: unknown
    /**
     * unique identifier of stack
     */
    id?: string
    /**
     * unique name of stack
     */
    name?: string
  } | null
}
/**
 * A pipeline transfer is the process of changing pipeline ownership along with the contained apps.
 */
export interface PipelineTransfer {
  [k: string]: unknown
  new_owner?: NewOwner
  /**
   * pipeline being transferred
   */
  pipeline?: {
    [k: string]: unknown
    /**
     * unique identifier of pipeline
     */
    id?: string
  }
  previous_owner?: PreviousOwner
}
/**
 * Previous owner of the pipeline.
 */
export interface PreviousOwner {
  [k: string]: unknown
  /**
   * unique identifier of a pipeline owner
   */
  id: string
  /**
   * type of pipeline owner
   */
  type: string
}
/**
 * New owner of the pipeline.
 */
export interface NewOwner {
  [k: string]: unknown
  /**
   * unique identifier of a pipeline owner
   */
  id: string
  /**
   * type of pipeline owner
   */
  type: string
}
/**
 * A pipeline allows grouping of apps into different stages.
 */
export interface Pipeline {
  [k: string]: unknown
  /**
   * when pipeline was created
   */
  created_at?: string
  /**
   * unique identifier of pipeline
   */
  id?: string
  /**
   * name of pipeline
   */
  name?: string
  owner?: Owner2
  /**
   * when pipeline was updated
   */
  updated_at?: string
}
/**
 * Rate Limit represents the number of request tokens each account holds. Requests to this endpoint do not count towards the rate limit.
 */
export interface RateLimit {
  [k: string]: unknown
  /**
   * allowed requests remaining in current interval
   */
  remaining?: number
}
/**
 * A release represents a combination of code, config vars and add-ons for an app on Heroku.
 */
export interface Release {
  [k: string]: unknown
  /**
   * add-on plans installed on the app for this release
   */
  addon_plan_names?: string[]
  /**
   * app involved in the release
   */
  app?: {
    [k: string]: unknown
    /**
     * unique identifier of app
     */
    id?: string
    /**
     * unique name of app
     */
    name?: string
  }
  /**
   * when release was created
   */
  created_at?: string
  /**
   * indicates this release as being the current one for the app
   */
  current?: boolean
  /**
   * description of changes in this release
   */
  description?: string
  /**
   * unique identifier of release
   */
  id?: string
  /**
   * Release command output will be available from this URL as a stream. The stream is available as either `text/plain` or `text/event-stream`. Clients should be prepared to handle disconnects and can resume the stream by sending a `Range` header (for `text/plain`) or a `Last-Event-Id` header (for `text/event-stream`).
   */
  output_stream_url?: null | string
  /**
   * slug running in this release
   */
  slug?: {
    [k: string]: unknown
    /**
     * unique identifier of slug
     */
    id?: string
  } | null
  /**
   * current status of the release
   */
  status?: 'failed' | 'pending' | 'succeeded'
  /**
   * when release was updated
   */
  updated_at?: string
  /**
   * user that created the release
   */
  user?: {
    [k: string]: unknown
    /**
     * unique email address of account
     */
    email?: string
    /**
     * unique identifier of an account
     */
    id?: string
  }
  /**
   * unique version assigned to the release
   */
  version?: number
}
/**
 * An ephemeral app to review a set of changes
 */
export interface ReviewApp {
  [k: string]: unknown
  /**
   * the Heroku app associated to this review app
   */
  app?: {
    [k: string]: unknown
    /**
     * unique identifier of app
     */
    id?: string
  } | null
  /**
   * the app setup for this review app
   */
  app_setup?: {
    [k: string]: unknown
    /**
     * unique identifier of app setup
     */
    id?: string
  } | null
  /**
   * the branch of the repository which the review app is based on
   */
  branch?: string
  /**
   * when test run was created
   */
  created_at?: string
  creator?: Creator
  /**
   * error message from creating the review app if any
   */
  error_status?: null | string
  fork_repo?: {
    [k: string]: unknown
    /**
     * repository id of the fork the branch resides in
     */
    id?: null | number
  } | null
  /**
   * unique identifier of the review app
   */
  id?: string
  /**
   * message from creating the review app if any
   */
  message?: null | string
  /**
   * the pipeline which this review app belongs to
   */
  pipeline?: {
    [k: string]: unknown
    /**
     * unique identifier of pipeline
     */
    id?: string
  }
  /**
   * pull request number the review app is built for
   */
  pr_number?: null | number
  /**
   * current state of the review app
   */
  status?: 'created' | 'creating' | 'deleted' | 'deleting' | 'errored' | 'pending'
  /**
   * when review app was updated
   */
  updated_at?: string
  /**
   * wait for ci before building the app
   */
  wait_for_ci?: boolean
}
/**
 * The user who created the review app
 */
export interface Creator {
  [k: string]: unknown
}
/**
 * Review apps can be configured for pipelines.
 */
export interface ReviewAppConfiguration {
  [k: string]: unknown
  /**
   * enable automatic review apps for pull requests
   */
  automatic_review_apps?: boolean
  /**
   * A unique prefix that will be used to create review app names
   */
  base_name?: null | string
  deploy_target?: DeployTarget
  /**
   * automatically destroy review apps when they haven't been deployed for a number of days
   */
  destroy_stale_apps?: boolean
  /**
   * unique identifier of pipeline
   */
  pipeline_id?: string
  repo?: {
    [k: string]: unknown
    /**
     * repository id
     */
    id?: number
  }
  /**
   * number of days without a deployment after which to consider a review app stale
   */
  stale_days?: number
  /**
   * If true, review apps are created only when CI passes
   */
  wait_for_ci?: boolean
}
/**
 * A slug is a snapshot of your application code that is ready to run on the platform.
 */
export interface Slug {
  [k: string]: unknown
  /**
   * pointer to the url where clients can fetch or store the actual release binary
   */
  blob?: {
    [k: string]: unknown
    /**
     * method to be used to interact with the slug blob
     */
    method?: string
    /**
     * URL to interact with the slug blob
     */
    url?: string
  }
  /**
   * description from buildpack of slug
   */
  buildpack_provided_description?: null | string
  /**
   * an optional checksum of the slug for verifying its integrity
   */
  checksum?: null | string
  /**
   * identification of the code with your version control system (eg: SHA of the git HEAD)
   */
  commit?: null | string
  /**
   * an optional description of the provided commit
   */
  commit_description?: null | string
  /**
   * when slug was created
   */
  created_at?: string
  /**
   * unique identifier of slug
   */
  id?: string
  process_types?: ProcessTypes
  /**
   * size of slug, in bytes
   */
  size?: null | number
  /**
   * identity of slug stack
   */
  stack?: {
    [k: string]: unknown
    /**
     * unique identifier of stack
     */
    id?: string
    /**
     * unique name of stack
     */
    name?: string
  }
  /**
   * when slug was updated
   */
  updated_at?: string
}
/**
 * hash mapping process type names to their respective command
 */
export interface ProcessTypes {
  /**
   * This interface was referenced by `ProcessTypes`'s JSON-Schema definition
   * via the `patternProperty` "^[-\w]{1,128}$".
   */
  [k: string]: string
}
/**
 * SMS numbers are used for recovery on accounts with two-factor authentication enabled.
 */
export interface SMSNumber {
  [k: string]: unknown
  /**
   * SMS number of account
   */
  sms_number?: null | string
}
/**
 * SNI Endpoint is a public address serving a custom SSL cert for HTTPS traffic, using the SNI TLS extension, to a Heroku app.
 */
export interface SNIEndpoint {
  [k: string]: unknown
  /**
   * application that this SSL certificate is on
   */
  app?: {
    [k: string]: unknown
    /**
     * unique identifier of app
     */
    id?: string
    /**
     * unique name of app
     */
    name?: string
  }
  /**
   * raw contents of the public certificate chain (eg: .crt or .pem file)
   */
  certificate_chain?: string
  /**
   * when endpoint was created
   */
  created_at?: string
  /**
   * unique name for SSL certificate
   */
  display_name?: null | string
  domains?: Domains
  /**
   * unique identifier of this SNI endpoint
   */
  id?: string
  /**
   * unique name for SNI endpoint
   */
  name?: string
  /**
   * certificate provided by this endpoint
   */
  ssl_cert?: {
    [k: string]: unknown
    'ca_signed?'?: boolean
    cert_domains?: CertDomains
    expires_at?: string
    /**
     * unique identifier of this SSL certificate
     */
    id?: string
    issuer?: string
    'self_signed?'?: boolean
    starts_at?: string
    subject?: string
  }
  /**
   * when SNI endpoint was updated
   */
  updated_at?: string
}
/**
 * A source is a location for uploading and downloading an application's source code.
 */
export interface Source {
  [k: string]: unknown
  /**
   * pointer to the URL where clients can fetch or store the source
   */
  source_blob?: {
    [k: string]: unknown
    /**
     * URL to download the source
     */
    get_url?: string
    /**
     * URL to upload the source
     */
    put_url?: string
  }
}
/**
 * Space access represents the permissions a particular user has on a particular space.
 */
export interface SpaceAccess {
  [k: string]: unknown
  /**
   * when space was created
   */
  created_at?: string
  /**
   * unique identifier of space
   */
  id?: string
  /**
   * user space permissions
   */
  permissions?: {
    [k: string]: unknown
    description?: string
    name?: string
  }[]
  /**
   * space user belongs to
   */
  space?: {
    [k: string]: unknown
    /**
     * unique identifier of app
     */
    id?: string
    /**
     * unique name of app
     */
    name?: string
  }
  /**
   * when space was updated
   */
  updated_at?: string
  /**
   * identity of user account
   */
  user?: {
    [k: string]: unknown
    /**
     * unique email address of account
     */
    email?: string
    /**
     * unique identifier of an account
     */
    id?: string
  }
}
/**
 * Network address translation (NAT) for stable outbound IP addresses from a space
 */
export interface SpaceNetworkAddressTranslation {
  [k: string]: unknown
  /**
   * when network address translation for a space was created
   */
  created_at?: string
  sources?: Sources
  /**
   * availability of network address translation for a space
   */
  state?: 'disabled' | 'enabled' | 'updating'
  /**
   * when network address translation for a space was updated
   */
  updated_at?: string
}
/**
 * Space Topology provides you with a mechanism for viewing all the running dynos, formations and applications for a space. This is the same data thats used to power our DNS Service Discovery.
 */
export interface SpaceTopology {
  [k: string]: unknown
  /**
   * The apps within this space
   */
  apps?: {
    [k: string]: unknown
    domains?: unknown[]
    /**
     * formations for application
     */
    formation?: Formation[]
    /**
     * unique identifier of app
     */
    id?: string
  }[]
  /**
   * version of the space topology payload
   */
  version?: number
}
/**
 * formations for application
 */
export interface Formation {
  [k: string]: unknown
  /**
   * Current dynos for application
   */
  dynos?: Dyno[]
  /**
   * unique identifier of this process type
   */
  id?: string
  /**
   * Name of process type
   */
  process_type?: string
}
/**
 * A dyno
 */
export interface Dyno {
  [k: string]: unknown
  /**
   * localspace hostname of resource
   */
  hostname?: string
  /**
   * unique identifier of this dyno
   */
  id?: string
  /**
   * process number, e.g. 1 in web.1
   */
  number?: number
  /**
   * RFC1918 Address of Dyno
   */
  private_ip?: string
}
/**
 * Transfer spaces between enterprise teams with the same Enterprise Account.
 */
export interface SpaceTransfer {
  [k: string]: unknown
}
/**
 * A space is an isolated, highly available, secure app execution environment.
 */
export interface Space {
  [k: string]: unknown
  /**
   * The RFC-1918 CIDR the Private Space will use. It must be a /16 in 10.0.0.0/8, 172.16.0.0/12 or 192.168.0.0/16
   */
  cidr?: string
  /**
   * when space was created
   */
  created_at?: string
  /**
   * The RFC-1918 CIDR that the Private Space will use for the Heroku-managed peering connection that's automatically created when using Heroku Data add-ons. It must be between a /16 and a /20
   */
  data_cidr?: string
  /**
   * unique identifier of space
   */
  id?: string
  /**
   * unique name of space
   */
  name?: string
  /**
   * organization that owns this space
   */
  organization?: {
    [k: string]: unknown
    /**
     * unique name of team
     */
    name?: string
  }
  /**
   * identity of space region
   */
  region?: {
    [k: string]: unknown
    /**
     * unique identifier of region
     */
    id?: string
    /**
     * unique name of region
     */
    name?: string
  }
  /**
   * true if this space has shield enabled
   */
  shield?: boolean
  /**
   * availability of this space
   */
  state?: 'allocated' | 'allocating' | 'deleting'
  /**
   * team that owns this space
   */
  team?: {
    [k: string]: unknown
    /**
     * unique identifier of team
     */
    id?: string
    /**
     * unique name of team
     */
    name?: string
  }
  /**
   * when space was updated
   */
  updated_at?: string
}
/**
 * Stacks are the different application execution environments available in the Heroku platform.
 */
export interface Stack {
  [k: string]: unknown
  /**
   * when stack was introduced
   */
  created_at?: string
  /**
   * indicates this stack is the default for new apps
   */
  default?: boolean
  /**
   * unique identifier of stack
   */
  id?: string
  /**
   * unique name of stack
   */
  name?: string
  /**
   * availability of this stack: beta, deprecated or public
   */
  state?: string
  /**
   * when stack was last modified
   */
  updated_at?: string
}
export interface TeamAddOn {
  [k: string]: unknown
}
/**
 * A team collaborator represents an account that has been given access to a team app on Heroku.
 */
export interface TeamAppCollaborator {
  [k: string]: unknown
  /**
   * app collaborator belongs to
   */
  app?: {
    [k: string]: unknown
    /**
     * unique identifier of app
     */
    id?: string
    /**
     * unique name of app
     */
    name?: string
  }
  /**
   * when collaborator was created
   */
  created_at?: string
  /**
   * unique identifier of collaborator
   */
  id?: string
  /**
   * array of permissions for the collaborator (only applicable if the app is on a team)
   */
  permissions?: TeamAppPermission[]
  /**
   * role in the team
   */
  role?: 'admin' | 'collaborator' | 'member' | 'owner' | null
  /**
   * when collaborator was updated
   */
  updated_at?: string
  /**
   * identity of collaborated account
   */
  user?: {
    [k: string]: unknown
    /**
     * unique email address of account
     */
    email?: string
    /**
     * whether the user is federated and belongs to an Identity Provider
     */
    federated?: boolean
    /**
     * unique identifier of an account
     */
    id?: string
  }
}
/**
 * A team app encapsulates the team specific functionality of Heroku apps.
 */
export interface TeamApp {
  [k: string]: unknown
  /**
   * when app was archived
   */
  archived_at?: null | string
  /**
   * identity of the stack that will be used for new builds
   */
  build_stack?: {
    [k: string]: unknown
    /**
     * unique identifier of stack
     */
    id?: string
    /**
     * unique name of stack
     */
    name?: string
  }
  /**
   * description from buildpack of app
   */
  buildpack_provided_description?: null | string
  /**
   * when app was created
   */
  created_at?: string
  /**
   * git repo URL of app
   */
  git_url?: string
  /**
   * unique identifier of app
   */
  id?: string
  /**
   * describes whether a Private Spaces app is externally routable or not
   */
  internal_routing?: boolean | null
  /**
   * is the current member a collaborator on this app.
   */
  joined?: boolean
  /**
   * are other team members forbidden from joining this app.
   */
  locked?: boolean
  /**
   * maintenance status of app
   */
  maintenance?: boolean
  /**
   * unique name of app
   */
  name?: string
  /**
   * identity of app owner
   */
  owner?: {
    [k: string]: unknown
    /**
     * unique email address of account
     */
    email?: string
    /**
     * unique identifier of an account
     */
    id?: string
  } | null
  /**
   * identity of app region
   */
  region?: {
    [k: string]: unknown
    /**
     * unique identifier of region
     */
    id?: string
    /**
     * unique name of region
     */
    name?: string
  }
  /**
   * when app was released
   */
  released_at?: null | string
  /**
   * git repo size in bytes of app
   */
  repo_size?: null | number
  /**
   * slug size in bytes of app
   */
  slug_size?: null | number
  /**
   * identity of space
   */
  space?: {
    [k: string]: unknown
    /**
     * unique identifier of space
     */
    id?: string
    /**
     * unique name of space
     */
    name?: string
  } | null
  /**
   * identity of app stack
   */
  stack?: {
    [k: string]: unknown
    /**
     * unique identifier of stack
     */
    id?: string
    /**
     * unique name of stack
     */
    name?: string
  }
  /**
   * team that owns this app
   */
  team?: {
    [k: string]: unknown
    /**
     * unique name of team
     */
    name?: string
  } | null
  /**
   * when app was updated
   */
  updated_at?: string
  /**
   * web URL of app
   */
  web_url?: null | string
}
/**
 * Usage for an enterprise team at a daily resolution.
 */
export interface TeamDailyUsage {
  [k: string]: unknown
  /**
   * total add-on credits used
   */
  addons?: number
  /**
   * app usage in the team
   */
  apps?: AppUsageDaily[]
  /**
   * total add-on credits used for first party add-ons
   */
  data?: number
  /**
   * date of the usage
   */
  date?: string
  /**
   * dynos used
   */
  dynos?: number
  /**
   * team identifier
   */
  id?: string
  /**
   * name of the team
   */
  name?: string
  /**
   * total add-on credits used for third party add-ons
   */
  partner?: number
  /**
   * space credits used
   */
  space?: number
}
/**
 * A Heroku team becomes delinquent due to non-payment. We [suspend and delete](https://help.heroku.com/EREVRILX/what-happens-if-i-have-unpaid-heroku-invoices) delinquent teams if their invoices remain unpaid.
 */
export interface TeamDelinquency {
  [k: string]: unknown
  /**
   * scheduled time of when we will delete your team due to delinquency
   */
  scheduled_deletion_time?: null | string
  /**
   * scheduled time of when we will suspend your team due to delinquency
   */
  scheduled_suspension_time?: null | string
}
/**
 * A team feature represents a feature enabled on a team account.
 */
export interface TeamFeature {
  [k: string]: unknown
  /**
   * when team feature was created
   */
  created_at?: string
  /**
   * description of team feature
   */
  description?: string
  /**
   * user readable feature name
   */
  display_name?: string
  /**
   * documentation URL of team feature
   */
  doc_url?: string
  /**
   * whether or not team feature has been enabled
   */
  enabled?: boolean
  /**
   * e-mail to send feedback about the feature
   */
  feedback_email?: string
  /**
   * unique identifier of team feature
   */
  id?: string
  /**
   * unique name of team feature
   */
  name?: string
  /**
   * state of team feature
   */
  state?: string
  /**
   * when team feature was updated
   */
  updated_at?: string
}
/**
 * A team invitation represents an invite to a team.
 */
export interface TeamInvitation {
  [k: string]: unknown
  /**
   * when invitation was created
   */
  created_at?: string
  /**
   * unique identifier of an invitation
   */
  id?: string
  invited_by?: {
    [k: string]: unknown
    /**
     * unique email address of account
     */
    email?: string
    /**
     * unique identifier of an account
     */
    id?: string
    /**
     * full name of the account owner
     */
    name?: null | string
  }
  /**
   * role in the team
   */
  role?: 'admin' | 'collaborator' | 'member' | 'owner' | null
  team?: {
    [k: string]: unknown
    /**
     * unique identifier of team
     */
    id?: string
    /**
     * unique name of team
     */
    name?: string
  }
  /**
   * when invitation was updated
   */
  updated_at?: string
  user?: {
    [k: string]: unknown
    /**
     * unique email address of account
     */
    email?: string
    /**
     * unique identifier of an account
     */
    id?: string
    /**
     * full name of the account owner
     */
    name?: null | string
  }
}
/**
 * A Team Invoice is an itemized bill of goods for a team which includes pricing and charges.
 */
export interface TeamInvoice {
  [k: string]: unknown
  /**
   * total add-ons charges in on this invoice
   */
  addons_total?: number
  /**
   * total charges on this invoice
   */
  charges_total?: number
  /**
   * when invoice was created
   */
  created_at?: string
  /**
   * total credits on this invoice
   */
  credits_total?: number
  /**
   * total database charges on this invoice
   */
  database_total?: number
  /**
   * total amount of dyno units consumed across dyno types.
   */
  dyno_units?: number
  /**
   * unique identifier of this invoice
   */
  id?: string
  /**
   * human readable invoice number
   */
  number?: number
  /**
   * status of the invoice payment
   */
  payment_status?: string
  /**
   * the ending date that the invoice covers
   */
  period_end?: string
  /**
   * the starting date that this invoice covers
   */
  period_start?: string
  /**
   * total platform charges on this invoice
   */
  platform_total?: number
  /**
   * payment status for this invoice (pending, successful, failed)
   */
  state?: number
  /**
   * combined total of charges and credits on this invoice
   */
  total?: number
  /**
   * when invoice was updated
   */
  updated_at?: string
  /**
   * The total amount of hours consumed across dyno types.
   */
  weighted_dyno_hours?: number
}
/**
 * A team member is an individual with access to a team.
 */
export interface TeamMember {
  /**
   * when the membership record was created
   */
  created_at: string
  /**
   * email address of the team member
   */
  email: string
  /**
   * whether the user is federated and belongs to an Identity Provider
   */
  federated: boolean
  /**
   * unique identifier of the team member
   */
  id?: string
  /**
   * Identity Provider information the member is federated with
   */
  identity_provider?: {
    [k: string]: unknown
    /**
     * unique identifier of this identity provider
     */
    id?: string
    /**
     * name of the identity provider
     */
    name?: string
    owner?: Owner
    /**
     * whether the identity_provider information is redacted or not
     */
    redacted?: boolean
  } | null
  /**
   * role in the team
   */
  role?: 'admin' | 'collaborator' | 'member' | 'owner' | null
  /**
   * whether the team member has two factor authentication enabled
   */
  two_factor_authentication?: boolean
  /**
   * when the membership record was updated
   */
  updated_at: string
  /**
   * user information for the membership
   */
  user?: {
    [k: string]: unknown
    /**
     * unique email address of account
     */
    email?: string
    /**
     * unique identifier of an account
     */
    id?: string
    /**
     * full name of the account owner
     */
    name?: null | string
  }
}
/**
 * Usage for an enterprise team at a monthly resolution.
 */
export interface TeamMonthlyUsage {
  [k: string]: unknown
  /**
   * total add-on credits used
   */
  addons?: number
  /**
   * app usage in the team
   */
  apps?: AppUsageMonthly[]
  /**
   * average connect rows synced
   */
  connect?: number
  /**
   * total add-on credits used for first party add-ons
   */
  data?: number
  /**
   * dynos used
   */
  dynos?: number
  /**
   * team identifier
   */
  id?: string
  /**
   * year and month of the usage
   */
  month?: string
  /**
   * name of the team
   */
  name?: string
  /**
   * total add-on credits used for third party add-ons
   */
  partner?: number
  /**
   * space credits used
   */
  space?: number
}
/**
 * Tracks a Team's Preferences
 */
export interface TeamPreferences {
  [k: string]: unknown
  /**
   * Whether add-on service rules should be applied to add-on installations
   */
  'addons-controls'?: boolean | null
  /**
   * The default permission used when adding new members to the team
   */
  'default-permission'?: 'admin' | 'member' | 'viewer' | null
}
/**
 * A space is an isolated, highly available, secure app execution environment.
 */
export interface TeamSpace {
  [k: string]: unknown
}
/**
 * Teams allow you to manage access to a shared group of applications and other resources.
 */
export interface Team {
  [k: string]: unknown
  /**
   * when the team was created
   */
  created_at?: string
  /**
   * whether charges incurred by the team are paid by credit card.
   */
  credit_card_collections?: boolean
  /**
   * whether to use this team when none is specified
   */
  default?: boolean
  enterprise_account?: EnterpriseAccount1
  /**
   * unique identifier of team
   */
  id?: string
  identity_provider?: IdentityProvider2
  /**
   * upper limit of members allowed in a team.
   */
  membership_limit?: null | number
  /**
   * unique name of team
   */
  name?: string
  /**
   * whether the team is provisioned licenses by salesforce.
   */
  provisioned_licenses?: boolean
  /**
   * role in the team
   */
  role?: 'admin' | 'collaborator' | 'member' | 'owner' | null
  /**
   * type of team.
   */
  type?: 'enterprise' | 'team'
  /**
   * when the team was updated
   */
  updated_at?: string
}
/**
 * A single test case belonging to a test run
 */
export interface TestCase {
  [k: string]: unknown
  /**
   * when test case was created
   */
  created_at?: string
  /**
   * description of the test case
   */
  description?: string
  /**
   * meta information about the test case
   */
  diagnostic?: string
  /**
   * special note about the test case e.g. skipped, todo
   */
  directive?: string
  /**
   * unique identifier of a test case
   */
  id?: string
  /**
   * the test number
   */
  number?: number
  /**
   * whether the test case was successful
   */
  passed?: boolean
  /**
   * the test node which executed this test case
   */
  test_node?: {
    [k: string]: unknown
    id?: string
  }
  /**
   * the test run which owns this test case
   */
  test_run?: {
    [k: string]: unknown
    id?: string
  }
  /**
   * when test case was updated
   */
  updated_at?: string
}
/**
 * A single test node belonging to a test run
 */
export interface TestNode {
  [k: string]: unknown
  /**
   * when test node was created
   */
  created_at?: string
  /**
   * the dyno which belongs to this test node
   */
  dyno?: {
    [k: string]: unknown
    /**
     * a URL to stream output from for debug runs or null for non-debug runs
     */
    attach_url?: null | string
    id?: string
  } | null
  /**
   * the status of the test run when the error occured
   */
  error_status?: null | string
  /**
   * the exit code of the test script
   */
  exit_code?: null | number
  id?: string
  /**
   * The index of the test node
   */
  index?: number
  /**
   * human friendly message indicating reason for an error
   */
  message?: null | string
  /**
   * the streaming output for the test node
   */
  output_stream_url?: string
  /**
   * the pipeline which owns this test node
   */
  pipeline?: {
    [k: string]: unknown
    id?: string
  }
  /**
   * the streaming test setup output for the test node
   */
  setup_stream_url?: string
  /**
   * current state of the test run
   */
  status?:
    | 'building'
    | 'cancelled'
    | 'creating'
    | 'debugging'
    | 'errored'
    | 'failed'
    | 'pending'
    | 'running'
    | 'succeeded'
  /**
   * the test run which owns this test node
   */
  test_run?: {
    [k: string]: unknown
    id?: string
  }
  /**
   * when test node was updated
   */
  updated_at?: string
}
/**
 * An execution or trial of one or more tests
 */
export interface TestRun {
  [k: string]: unknown
  /**
   * the email of the actor triggering the test run
   */
  actor_email?: string
  app_setup?: AppSetup
  /**
   * whether the test was run with an empty cache
   */
  clear_cache?: boolean | null
  /**
   * the branch of the repository that the test run concerns
   */
  commit_branch?: string
  /**
   * the message for the commit under test
   */
  commit_message?: string
  /**
   * the SHA hash of the commit under test
   */
  commit_sha?: string
  /**
   * when test run was created
   */
  created_at?: string
  /**
   * whether the test run was started for interactive debugging
   */
  debug?: boolean
  /**
   * the type of dynos used for this test-run
   */
  dyno?: {
    [k: string]: unknown
    /**
     * dyno size
     */
    size?: string
  } | null
  /**
   * unique identifier of a test run
   */
  id?: string
  /**
   * human friendly message indicating reason for an error
   */
  message?: null | string
  /**
   * the auto incrementing test run number
   */
  number?: number
  /**
   * the team that owns this test-run
   */
  organization?: {
    [k: string]: unknown
    /**
     * unique name of team
     */
    name?: string
  } | null
  /**
   * the pipeline which owns this test-run
   */
  pipeline?: {
    [k: string]: unknown
    id?: string
  }
  /**
   * The download location for the source code to be tested
   */
  source_blob_url?: string
  /**
   * current state of the test run
   */
  status?:
    | 'building'
    | 'cancelled'
    | 'creating'
    | 'debugging'
    | 'errored'
    | 'failed'
    | 'pending'
    | 'running'
    | 'succeeded'
  /**
   * when test-run was updated
   */
  updated_at?: string
  user?: Account
  /**
   * human friently warning emitted during the test run
   */
  warning_message?: null | string
}
/**
 * Tracks a user's preferences and message dismissals
 */
export interface UserPreferences {
  [k: string]: unknown
  /**
   * User's default team
   */
  'default-organization'?: null | string
  /**
   * Whether the user has dismissed the getting started banner
   */
  'dismissed-getting-started'?: boolean | null
  /**
   * Whether the user has dismissed the GitHub link banner
   */
  'dismissed-github-banner'?: boolean | null
  /**
   * Whether the user has dismissed the Organization Access Controls banner
   */
  'dismissed-org-access-controls'?: boolean | null
  /**
   * Whether the user has dismissed the Organization Wizard
   */
  'dismissed-org-wizard-notification'?: boolean | null
  /**
   * Whether the user has dismissed the Pipelines banner
   */
  'dismissed-pipelines-banner'?: boolean | null
  /**
   * Whether the user has dismissed the GitHub banner on a pipeline overview
   */
  'dismissed-pipelines-github-banner'?: boolean | null
  'dismissed-pipelines-github-banners'?: DismissedPipelinesGithubBanners
  /**
   * Whether the user has dismissed the 2FA SMS banner
   */
  'dismissed-sms-banner'?: boolean | null
  /**
   * User's default timezone
   */
  timezone?: null | string
}
/**
 * [VPN](https://devcenter.heroku.com/articles/private-space-vpn-connection) provides a way to connect your Private Spaces to your network via VPN.
 */
export interface PrivateSpacesVPN {
  [k: string]: unknown
  /**
   * VPN ID
   */
  id?: string
  /**
   * IKE Version
   */
  ike_version?: number
  /**
   * VPN Name
   */
  name?: string
  /**
   * Public IP of VPN customer gateway
   */
  public_ip?: string
  routable_cidrs?: RoutableCidrs
  /**
   * CIDR Block of the Private Space
   */
  space_cidr_block?: string
  /**
   * Status of the VPN
   */
  status?: 'active' | 'deprovisioning' | 'failed' | 'pending' | 'provisioning'
  /**
   * Details of the status
   */
  status_message?: string
  tunnels?: Tunnel[]
}
/**
 * Tunnel info
 */
export interface Tunnel {
  [k: string]: unknown
  /**
   * Public IP address for the customer side of the tunnel
   */
  customer_ip?: string
  /**
   * Public IP address for the tunnel
   */
  ip?: string
  /**
   * Timestamp of last status changed
   */
  last_status_change?: string
  /**
   * Pre-shared key
   */
  pre_shared_key?: string
  /**
   * Status of the tunnel
   */
  status?: 'DOWN' | 'UP'
  /**
   * Details of the status
   */
  status_message?: string
}
